questioning the heart of software was this subtitle of my book because to me that was the point of the book domain-driven design then is a term to capture this particular approach the way of dealing with this the way of doing this important thing of course this presumes that you know that you can find that heart of software which i think is the domain that we're working on is where the complexity is and i think that that generally you know that there that is often true but often i'm asked like well what exactly is domain driven design i mean it is a hard thing to define kind of it and i understand why people sometimes are concerned like doesn't seem like you've given us a really sharp definition and i mean on the one hand i say look there's basically these few things that the point of domain driven design or rather the the principles of domain driven design is that we would find that core complexity in a critical part of our domain and we will focus on that not focus on the technical platform but on the domain and in particular on high value difficult parts in that domain and then in particular how do we deal with that complexity in those high valued complex parts what we develop models of them but we don't just say okay this is the design phase or whatever and we're going to make a model and it's going to be this nice big uml diagram and now it's time to program it's an integral part of the whole process of development and it goes on and on so that's why i always say exploring models furthermore we explore models in a in a particular engagement with business people or with domain experts assuming it's a business domain and that would be actual business people in other words this modeling is something that businesspeople and software experts do together we don't say to the business people you're the ones who know the business so give us a model which some people have proposed and we don't say well we are the ones responsible for the software so we'll develop the model which is what happens by default most of the time we say this is really something that if it's going to come out well it needs to be done together and then there's this point that the software should express that model that a model that is just a diagram we draw on the board or even a wonderful discussion we had with our business people that if we come up with these nice sharp concepts and so forth that guide and then we do nothing with it nothing tangible in the software then it really hasn't done as much good maybe it's of some value but in domain driven design there's this principle that the software should explicitly reflect that model and then that leads to the ubiquitous language how does it reflect that model anyway well the structure is in the model the structures that the model suggests should show up in the software of course but the words the language a lot of domain driven design the philosophy of it revolves around how integral languages to the way that we do these things so that in the end all this collaboration exploration and even the programming the thread you can see running through it is the evolution of this language for talking about the domain problems in increasingly precise and expressive way to the point where you can write code that really says that's like i just reads like an expression of this is the solution we've chosen for our problem now ubiquitous means everywhere and when i say ubiquitous then i mean when i'm talking to a business person or when i'm talking to another technical person or when i'm programming the computer when i'm writing a document but it doesn't mean everywhere without throughout the system and so i have to say ubiquitous language within a bounded context a bounded context is a recognition that language doesn't mean anything in general all the things i'm saying only makes sense to you if if they do make any sense to you but they only make sense to you because of the context in which i'm saying them you know the things i've said before you know the things in mafiosos introduction and other information that you bring to bear to say okay that's what this word means now that's what this phrase means now but it didn't just mean that if you had just seen the sentence i am saying now on a billboard driving to this place you wouldn't have known what it meant so when you're reading code in a computer program the same is true you can't just look at one line of code and know what it means you know what it will do you have to usually read quite a bit of code that comes in other parts of the program the code that comes before it in the particular process it's in the code that is referenced by any kind of dependency in that code so in order to understand the line of code you have to know all these things bounded context says we're not going to rely on this kind of well i'll just figure it out as i go along i'll look up you know every line of code and then every reference it makes and then by the time i get to that line i'll know what it means what it will do we're saying we will define some concepts and within a boundary that we have specified this will be a very consistent meaning and that we will have some rules and within that boundary those rules will apply very consistently and rigorously and you say well of course that's just what modeling is all about what good design is all about but the thing is without the boundary it doesn't work it doesn't even make sense if i you know to take an extremely simple example if i said there's a number x and a number y and x will always be less than y and now you see some calculation in my program and it says y minus x then you know that that will be a positive number because x is always less than y i said so and now you go and you look at another computer program and you see y minus x you see that actual text somewhere in the program is it a positive number maybe maybe not maybe it's not even a number you simply do not know and you cannot know there is no meaning to expressions outside of a given context so domain-driven design tries to acknowledge that and use that to our benefit use it in several ways one of which is simply to say if we really want this to work then we need that boundary i need to be able to draw around me so that i can do all the cool stuff that i want to do inside that boundary the boundary has to be tangible it's a real piece of software or markers within the software and that's the first and most basic way in which it's important to domain-driven design another way it's important to domain-driven design is to say we aren't going to have just one model but probably several models because we have a big sprawling domain that has many problems multiple complex important problems and we want to address them differently so just as we have many tools for every kind of work we do we have many models to address a specific domain a third way in which it's important is that most projects of any size have multiple teams and different teams cannot coordinate us tightly around i mean to accomplish the kind of clarity and consistency that i was talking about earlier you need a very well coordinated team to do that two teams each can coordinate within themselves but they can't coordinate as well with each other and so they can't accomplish that kind of consistency between them well they can or in one particular way they can do it by freezing the model in place by deciding in advance what the rules are and then not breaking them but if you want to be able to make strict rules and then adjust any of all of them quickly in response to new insights then you need to be able to do that within a team so the fact that we usually have multiple teams working is another reason that we need bounded context anyway so that's basically the gist of domain driven design and now i know that even so i think what i said probably doesn't sound like a very i don't know it's it's not a reductionist kind of an attitude i think you know i i think i've given up on trying to have that very crisp little definition of domain-driven design it's kind of a it's kind of a gestalt that after a while it is sort of a way that you look at every problem no not every problem of course but the sorts of problems they address as well like complex domains where you want to write software and it gives some guidance and then of course there are some concrete techniques that we tend to use but those are more flexible more fluid at this conference you'll see people presenting about different ways of doing some of those things and so as i say i don't know if i can really define it in that sort of way and of course one important thing about it it gives us some terminology some ways of talking about some of the important things we're doing even if we don't exactly agree on the technique that we're applying to it so for example to have the word bounded context to describe and say i think that the boundary of this context has some problems and that actually means something to the other person that's one of the valuable thing now why is it that 12 years after my book was published we're actually still talking about domain-driven design and not only it's still talking about it but actually in some ways amping up the conversation because this is as you said the first the first real conference of our own and how is that i don't know i mean it's kind of a surprise to me but truly but i mean a very pleasant one but i think one reason one possibility anyway involves technology and that's kind of a funny thing to say after making the point that the first point of domain-driven design was to focus on the core complexity in the heart of the domain and so on and that we emphasize those domain problems and not the technical ones and not the technology and so on and it's true the domain driven design isn't about technology and in fact i mean part of what made me write it was a bit of a response to what i saw around me that all the best software designers were always focused toward the technical aspects of the software and it was like we just left the b-team people the that is the the less talented people to work on the actual business problem it was even considered it was certainly considered less prestigious maybe it still is but i thought that was missing the whole point but even though i think that domain driven design is not about technology that doesn't mean that we are indifferent to the technology the technology is very important i think the best domain driven design practitioners are actually masters of the technology it's like if a if you said well i'm a master carpenter and i like to make furniture handcrafted furniture and that mean let's say i i particularly like to make like artistic tables and so you would say that that person was a master of using hammers and saws and chisels and all of these things i'm sure but if you asked him well what is what you do about he wouldn't sell it's all about the saws the way i use saws and chisels and now he would say we'll see this kind of wood and this kind of you know i like the when the legs are kind of like this and he would talk about tables all the time and he would be thinking about tables all the time what makes that possible in part is because he's mastered the other tools so thoroughly that he doesn't have to focus on those when i go to do a project involving something like that i have to put so much of my attention on just using the saw and not ruining everything that you know i don't create that kind of a piece of art you have to master the tool first and then you can actually focus on that thing and so i think that you know when you when you talk about domain driven design it's almost as if we've said well yes because we have so mastered the technology that now we can look at the real problem and bring our tools to bear so it's no kind of excuse to not be a master of technology and that means we have to keep up a breast of what's there and what's available and so i started this saying well why would 12 years later maybe domain driven design being more interesting to people than it was when it was written one possibility is that there's a combination of better tools and a community better at using those tools and now they're actually ready to focus on the real problem and why would i say that there are better tools left side trim we like to think that you know time as time goes along our technology gets better i think in general that's true over long periods of time but let me think back to 2003 the books 2004 but of course that means it was written in 2003 writing it reflects the environment at the time it was written in and i think that was not a good time from a software technology point of view i started out you know as a professional programmer i started out in the early 90s and actually that was a good time the early nineties at least in the little world that i was in and i was a small talk programmer on wall street working in an investment bank i may have been you know it may have been a bit in the service of evil but it was very interesting and very had wonderful technology very wonderful complex problems to dig into and small talk you know you probably heard a lot of old guys like me wonder is talking about wonderful it was and it was but i i don't want to bring it back or anything but 2003 wasn't so wonderful i mean now don't get me wrong i actually am not one of the people who says i hate y'all i just hate job i actually think job is okay the problem here isn't the java it's the only java right the only language anyone used in 2003 was java and sometimes c sharp which at that time was just a dialect of java and i mean let's you know face it there was hardly any difference back then and java 5 you know not picking on that version i'm just saying actually when you look at java 8 i think it's like a different language than the old java it's much better but if java 8 were all we had i'd be complaining about that right it's we are out at that time when that was there was one language and only one language but it wasn't really java that i didn't like as i said j2ee and not speak on j2e in particular but all all the frameworks of the era where the heaviest complicated as things you've ever seen remember i said we have to attack complexity those the critical complexity of the problem which i said is some aspect of the domain that is really crucial to their success and maybe a big opportunity or really yeah but what if you just make the technology itself so complicated that it's more complex than any part of the business problem you're trying to solve then that will shift the focus right and quite appropriately you should apply your attention to the most difficult part of what you're doing and it's the most difficult part of that is getting some kind of a you know j2ee container to start then that's where you got to put your best people now about that time i think people were mostly using spring so i could roll back to like the year 2000 and things were even worse because ej bees are one of the things i hated the most in my whole career but by this time spring had rescued us from that now i know that people these days they talk about spraying so complicated springs so heavy and i get it i do i even basically agree but you got to realize what spring rescued us from we should be so grateful for spring spring was the turning point that's when things started to go the other direction so no i will always be grateful to them sequel actually i love relational databases but when you say all data will be in relational databases then that means you have to squeeze all data into that shape and that was the reality of 2003 and oh yes vor mapper i forgot that part because i always try or mappers you know i think the i know the guy i think who wrote the very first or mapper brilliant guys i don't think he intended that this would become the only way of storing data i think his poor purpose really was to say well until we have object stores or some other better way of storing data this will at least allow us to move back and forth between our objects and our relational database but we kind of got stuck stuck with all our mappers for 10 years or even 15 years okay i think the less said about some things the better some things are just best left in the past but there are a lot of things happening back in that early 2000s that in the late 90s another thing that happened in the late 90s was a huge influx of new programmers because of the dot-com explosion and other things and the problem was i think that it on average it was not a very skilled bunch and not a very committed bunch i mean people didn't care the way that before and after when we were in less heated up periods of time when people came into the world of software because they were really fascinated by software and wanted to learn the graph is that probably had an effect too so let's move to the let's move up to the present well so yeah apparently sound doesn't work on this so i'll just skip this part but you guys probably didn't watch classic cycles star trek anyway so the question would be you know maybe one of the reasons that in 2004 the uptake of domain driven design was uneven to say the least it's because it was just too hard the tools were not right for it look what we're expecting people to do we want them to express a model in code you know we want them to we want code that reads as if you are reading a document that explained how you solve the problem how you think about the problem and how you solve it that would be the ideal code and yet you're supposed to do that on top of all that mess that i was just describing even the you know the building blocks which have been over-emphasised but even those are hard to pull off with that technology set you know in en a with an o our mapper and so forth how do you mark off aggregates it's really hard we say things like you know define these value objects and make them immutable and in the book i you sort of talked a little bit about that but you know it's really hard really hard at that kind of technology to do it and context boundaries i just said that but when you're running on a monolithic server application where everything max into the same database how do you do that how do you actually say yeah this is the this is the realm of the software in which i can make assertions that i'm very confident of about the definitions of things the constraints between the things well you know it can be done i did it some i was involved with teams that did it sometimes and i saw other people do it but it's very hard maybe too hard so you know i think that if you took that master carpenter and you said well here is stone hand axe made by a early crow manion and you said now make your beautiful artistic table maybe maybe you wouldn't get the same result so maybe that's the situation now the question would be things have changed right the no sequel movement comes along and suddenly we have all these different kinds of databases you kind of hopefully have a database that fits the data that you're working with better and we have vast quantities of memory to work with so that for a lot of kinds of problems instead of saying well i'm going to take the object from store and do something and put it back and over and over i'm saying well a lot of the really intricate parts the complex parts that i want to work on i could bring data in i could transform it into a structure that i'll just let live in memory any kind of interesting results i can write out to the store and i don't really have to worry about that part you know the so that lifts a big constraint and you know then we have sort of new ideas come along about well maybe we should just structure our whole model and design differently anyway things like event sourcing so you could say maybe maybe things maybe we can do better now maybe we're ready maybe not you know i mean maybe we're still not there i don't know but i think i think it seems to me that when i'm working with the tools of 2015 you know now going on 2016 it feels different it feels better more like more like 1994 actually strange that sounds but but better you know it's as if we have finally recovered from that year and finally got back on a path and gotten to a place better than than anything i've seen before could be that the you know could be i'm still premature about this but i don't think so i think we're ready so you know i think look at the just the intention of the technologies and the frameworks and stuff that people come out with now they tend to be so much smaller and and easier to work with it's like they care about it being easy to work with and express it like they have in their at their at their framework or library level they have created a ubiquitous language one of my favorites at the moment and it serves as a good example of the kind of thing i'm talking about is the reactive extensions that if you don't know what that is you should really look it up it's just it's a wonderfully elegant model and it's been implemented on in i think it started out in c-sharp not sure i think so this it's in java it's in closure it's in everything now and it's a good example of its deals with technical concerns how do you do you know how do you tie together these multi-threaded problems and and yet not not just get overwhelmed so that you have to think about that all the time and so we're in this period where we don't have only this or only that of anything and that's great and i think that's when you can actually you know people flock toward things generally speaking they're flocking toward things that really are rather nice and then there's a new explosion of variation around that let me just quickly talk about one thing because since domain-driven design is so much about models and and there have been a lot of misconceptions about domain-driven design over the year it was a big over emphasis on the building blocks for example and when you go into something like functional programming or whatever you're going to have to really rethink those building blocks but the fundamentals like we are trying to develop a model that's the real fun you know that's one of those real fundamentals of domain driven design but if you are but it only works if you're thinking about model in a certain way if you think of model as a way of structuring domain the you know objects in an object-oriented programming language and you say well then ddd is very specific to a particular kind of programming environment but that's just not true even though all the examples nearly all the examples in my book are that way that's because it was 2003 and we only had one language so let me just talk a little bit about what i mean by model and some of you heard me say this so that people often talk about you know maps and use it as an example of a model and of course that's perfectly appropriate but it's not quite the kind of model that i am thinking of but it does help it's something i can use to explain what i mean by model so here is a map of the world and everyone looks at it and says okay here's a map of the world and you can look at it and learn and infer certain things like i'll bet you can infer where this map was made so but in addition to that you can look and say okay well let's see there's china there's the united states and they look about the same size and you can look in the wikipedia and all of you see yeah they are about the same size so okay you can tell how big things are and you can see that you know western europe's a bit smaller and to the east and china's to the west and all that you can look and see okay africa and greenland they look about the same size so i suppose they are i mean we tested it with the us and china so it must work generally now and now that we know that greenland is the same size as africa we can continue okay so well greenland is not the same size as africa it turns out i did look it up to see how exactly how big the two are actually africa is 14 times bigger than greenland 14 times so why is the map like this well theory number one bad data the people who made this map just didn't know how big greenland was or africa this turns out not to be the explanation theory number two since the map was made in the us but that the team that made up the map had a couple of immigrants from greenland they said americans don't know anything about geography if we tell them greenland's really big they'll make it big on the map and no one will ever know the difference that turns out not to be the explanation either the explanation actually turns out to involve a belgium from the 1590s named rick cotter i'd probably mispronounce the name but i'm sure you know who i'm talking about now at that time navigating was a tricky business you know just figuring out which direction to go and they had all kinds of maps and techniques for doing it they were fairly complicated to use and he figured out a way to make a better map for navigators and that and it explains why these things are distorted in the way they are now everyone knows of course that the map is that we have to distort something to take the surface of the round earth and flatten it out but this one's flattened out in a very particular way there are other ways to flatten out here this is my cards way this is his projection so the curious thing about this one is that if you draw a straight line between two places let's say you drew a line between lisbon and new york and then you look at the angle of that line on that map you can get a compass setting from that if you were to stretch a string around the globe and measure the angle of that string on the globe it would be the same angle as the one you get on the map so that as the as the surface of the round earth is flattened onto the map it's done in a way that makes the directions of things stay the same no matter what else has to be distorted the directions of things stay the same that's what makes the mercado maps so valuable or what made it so valuable you know hundreds of years ago and we use it for other things like teaching geography and school and so children grow up thinking that greenland is enormous but but that's the reason it wasn't made for them it was made for navigators here's another projection this one doesn't distort the sizes of shapes of things we could use this one instead but this one might be confusing to navigators if you were trying to get from new york to lisbon for example and you have to go through that white part so here's the model as i see it this is marketers model the earth is a sphere so we start by saying well this thing are the domain i'm making an abstraction of it and i've taken away nearly everything that about right this is not a kind of complete thing i'm not saying everything about the earth then we're going to say well what data do i want i want the locations of certain things on the surface mostly coastline major port cities may be navigable rivers and i want the i want the state in a particular form i probably needed an aspherical coordinate system because this is i've described the earth as a sphere so that's latitude and longitude a greek concept that they that's handy for that and then i need to turn it into a flat piece of paper so i need a little formalism they're a mathematical technique called the projection now of course mercato's mathematical techniques were a little different than what we would use today i'll just accept you know i'm just talking in modern mathematical terms what he did was but what he did was functionally equivalent to that and then we have an assertion an assertion that if you apply this particular projection this particular formula for converting a sphere to a flat surface that you will be able to say that any direction on the flat surface is the same as this is the direction on the surface of the sphere that assertion of course is what makes the thing valuable and this is now now how is this different from the map itself because if i take a different data set and i apply the same model then let's say we take the data set available to someone from the 1590s then i will get well in this case this is what i get this is marketers original model i mean its original map and although it is doesn't look exactly like a modern map it's actually based on the exact same model it's just the data set that's different so if we zoom in on this is europe and the mediterranean you can see that it actually looks a lot like the modern map and that's because they had good data for that region but as you go further afield you get less and less you know the the east coast of north and south america look pretty good there's some mistakes the west coast though of south america for example it's a funny thing that details look okay but the whole things shifted hundreds of miles to the east like there's an offset error in the data offset error saw and then look at the west coast of north america it's like okay we know there's a west coast there so they really didn't have much data and then look down here in the southern areas say around where we would put australia and i don't know i don't know what's going on there some bad data so hopefully this starts to connect with the kind of things we do we take a sprawling complex domain just an overwhelming quantity of data and then we abstract that domain in a way that allows us to focus on some particular important problem particular important problem and then apply a model that will transform that data into a form that really supports thinking about that problem and coming to decisions about it i mean some models are for different you know some models help you predict something some models help you make a decision but and they all evolved i mean this is a poor tolan map it's the kind of map one of the kinds of maps that was available before mccotter i'm sure it was one of the things that he drew upon as he was figuring out and those those sort of radiating lines they allow you to know the direction between two points but specific points so on this map you can say well from these known points i know the direction from that known point to that known point mercator had this brilliant breakthrough in his model where suddenly he could go from any point to any other point right but it wasn't like it came out of nowhere so as we are working on these domains it's not like we should feel frustrated that oh you know my model doesn't have the elegance of the mercator projection now it's like you take steps this was a tremendously valuable map in its time one of the distractions though i mean you know i wasn't talking about what do i mean by model i'm not talking about trying to see the reality of the business or anything that i think is actually a distraction it gets us off on the wrong track - for example is this a realistic image of the world i mean i don't think that greenland is almost the size of africa so that you could say is is unrealistic we could fix that we could make greenland smaller and probably that wouldn't cause too much trouble because how many how much how often do navigators go to greenland but we would make have to make our assertion slightly different now the assertion is that any to the angle between any two points on this map is the same as it would be on the globe unless one of the two points is in greenland or we could say well africa is really too small on this map so let's enlarge it a little bit make it more realistic but now we have to adjust the assertion the angle of you know the direction between any two points on the map is the same as on the sphere unless one end of it is in africa and the other end out or one end is in greenland and the other and out and by the way doesn't that start to sound a little bit like code so that's how we end up there is this more realistic than the ricotta map i mean it shows greenland and africa in their true size i mean their relative size on the other hand it doesn't give you a sense of the connected geography of the world the same way that the marcato map does you know you can't really relate for example you know south america and africa look as if they're on the opposite ends of the world i don't think it's more or less realistic i think that's the wrong question to ask if you want realistic there's realistic well this is a projection to but it's you know what i mean by realistic i guess what i'm getting at here is that realism doesn't have much to do with what we're doing we're writing software we're trying to solve problems we need models that are focused specifically on those problems and a narrow focus when you lose the narrow focus then you get this this is something i found on the web somewhere by googling for model so we need to remember keep remembering we are folk we need to find a focus on a specific problem on a specific reasonably complex problem because if it's not complex why are you doing all this and an important problem because if it's not important why are you doing this and then we apply all those tools and and and so when i say hey you know we don't want a realistic model we want a useful model that sounds like oh yeah you know and want to be good but i don't mean it that way a i mean to say look usefulness isn't like good usefulness is specific you can't say that something is useful or not in general you know is a is a hammer useful well not if you want to cut a board in two pieces then maybe a saw is useful is it's all useful well not if i want to pound a nail into a board right so things are useful relative to some specific problem not in general there's nothing that's generally useful just what you were going to keep in mind with the models in fact it's quite easy to find something that is not useful for anything a lot of you know okay there we go it's easy to find something that's not useful for anything actually this might be useful for one thing which is i need to have a kind of generic schema that i can just shove all our data into as a kind of a repository of some stuff that we might look up from time to time but if you're actually trying to do the things that domain driven design is focused on this is not useful well as was saying and i want to wrap up with a little optimism because sometimes i don't sound very optimistic because i talk about how not all of a large system will be well designed and i talk about all the dysfunction in a large organization that is going to make sure that is always true and the intrinsic difficulty of software development that will ensure that it's always through anyway and so people say oh this is sound this makes me feel bad well i don't mean it that way i mean it like let's be realistic not all of the software will be well-designed and so we'd better focus create a boundary and make one piece that's well designed an important piece but optimism because i think there's reason to think that the present and the future are going to be better than the recent past in a way you could say that we have at this point at least three maybe more actual modeling paradigms as i said in 2003 everything was object-oriented if you wanted to do you know if you wanted to use models in software object-oriented was the first place the first paradigm of programming that took that concept seriously but we have more now i mean and by the way i love object-oriented programming and i know it's a little out of vogue right now and i actually find out quite refreshing i'm enjoying doing things in different ways in fact but this is one of the options we have now event sourcing i would say after thinking about it for a few years that it's essentially a different modeling paradigm it says you know that you'll represent things primarily as a sequence of events and then you will infer or you will project from those events to create a view of whatever it is that you're interested in and it eliminates mutation of data and it can be very expressive for certain kinds of problems but your model takes a different shape it's not like well okay let's figure out what the model is and now we're going to program it in whatever language that we choose independently now the to shape each other you have to create a model that fits the paradigm that you're going to use to build it relational i think relational is a genuine modeling paradigm it was intended to be bad they had you know er models and but we stopped using it for that basically because it became for a decade or more just a bad way to store objects and so people have practically forgotten what a really powerful tool it is if you actually say hey this is a problem where we have to of compare and manipulate big sets i'm going to actually just express that in terms of sequel queries and i'll i will create a schema that is actually tailored to the problems i'm trying to compute about that's not the kind of schema people have made for the last 20 years in my experience they create schemas that are meant to be sort of generalized places to put all of our data that's not what i mean by you know a model and that's not what i mean when i say relational is a paradigm that you can use for domain driven design i mean though if you say ok i'm not going to use that schema it's fine for that one to exist if i'm not using it for this what i'm going to do is create a schema where we take just the information we want to apply and structure it in a certain way that allows us to do you know set operations basically to find our answer so in that sense i think it's a modeling paradigm and then functional now you know functional is a big thing maybe more than one thing and so there are people though who have been talking about modeling in the functional realm and doing very interesting things the thing is models are just systems of abstraction and so if you have a powerful mechanism for abstraction you should be able to implement you should be able to express models furthermore if you want to you know bring that ubiquitous language to life in the code well some of the functional languages i think are really nice for making making language in the code and it might be a good mate with events or sammy i'm just sort of laying out like i'm pointing out that we have so many options options that were really not there in 2003 and graphs graph databases it's more than just a way to store data store highly connected data that's the way they describe it that's not what i think about when i look at it i think this is a way to model certain kinds of problems you know and and it's brilliantly clear you know this is one of those classic kind of modeling paradigms it goes back long before computers so anyway and maybe this one will come along but so in a nutshell i would say that maybe it's a good time to be taking ddt to the next level a little bit maybe our tools are ready maybe there are things too that are pushing us toward toward more concern about design if you look at the typical you know cloud-based application or or mobile you you know tying all these things together it becomes perhaps a bit more that is you can't get away with some of the sloppiness that you can get away with if everything's together on one server and the fact that you will not be forgiven for sloppiness leads to people thinking about the design and wanting to have assertions about what will happen for example so having those pressures you know why does why a software sometimes been so bad i think one of the reasons is because you can get away with so much you know the someone once said that if if you built a bridge the way that people typically write software that this it would fall down in the slightest breeze and yet there are no breezes so you know it works well kind of but and and also the same for like efficiency you can kind of get away with roundabout ways of doing things but the environment that we're in just at this moment might be less favorable that might be putting more pressure so that might be another reason that things are going another way well basically that's what i wanted to say i want to say that i feel pretty positive i mean i see you know we announced this thing and we thought it might be like a hundred people or two hundred people maybe and then five hundred people showed up and then we had to stop i mean so that was exciting and i hope that you know this this conference is about to happen will fulfill your expectations expectations i think it i think it will i'm rather excited about some of the things that are happening i'm going to go around now see i've done mine so i get to just focus on other people's talks in the and some of the model with strangers stuff that sounds fun so i'm really looking forward to all about
